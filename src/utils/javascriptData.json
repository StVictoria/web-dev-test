{"data": [
    {"id": 1,
    "block": "Основы JavaScript",
    "topic": "Строгий режим",
    "level": "low",
    "question": "Что нужно сделать, чтобы код работал в современном режиме?",
    "answer": "Директива выглядит как строка: 'use strict'. Когда она находится в начале скрипта, весь сценарий работает в «современном» режиме. 'use strict' можно поставить в начале большинства видов функций. Это позволяет включить строгий режим только в конкретной функции. Но обычно люди используют его для всего файла."
    }, 
    {"id": 2,
    "block": "Основы JavaScript",
    "topic": "Строгий режим",
    "level": "low",
    "question": "Как отменить строгий режим use strict?",
    "answer": "Никак. Нет директивы типа 'no use strict', которая возвращала бы движок к старому поведению. Как только мы входим в строгий режим, отменить это невозможно."
    }, 
    {"id": 3,
    "block": "Основы JavaScript",
    "topic": "Переменные",
    "level": "low",
    "question": "Что такое переменная?",
    "answer": "«именованное хранилище» для данных."
    }, 
    {"id": 4,
    "block": "Основы JavaScript",
    "topic": "Переменные",
    "level": "low",
    "question": "Какие есть ограничения касающиеся имён переменных?",
    "answer": "Имя переменной должно содержать только буквы, цифры или символы $ и _. Первый символ не должен быть цифрой."
    }, 
    {"id": 5,
    "block": "Основы JavaScript",
    "topic": "Типы данных",
    "level": "low",
    "question": "Сколько типов данных существует? Перечислить их.",
    "answer": "8 типов данных: number, BigInt, boolean, string, null, undefined, object, Symbol"
    }, 
    {"id": 6,
    "block": "Основы JavaScript",
    "topic": "Типы данных",
    "level": "low",
    "question": "Что такое NaN? В результате чего появляется?",
    "answer": "NaN означает вычислительную ошибку. Это результат неправильной или неопределённой математической операции. Значение NaN «прилипчиво». Любая операция с NaN возвращает NaN."
    }, 
    {"id": 7,
    "block": "Основы JavaScript",
    "topic": "Типы данных",
    "level": "low",
    "question": "Что за тип BigInt? Как записать такое число?",
    "answer": "Тип BigInt был добавлен в JavaScript, чтобы дать возможность работать с целыми числами произвольной длины. Чтобы создать значение типа BigInt, необходимо добавить n в конец числового литерала."
    }, 
    {"id": 8,
    "block": "Основы JavaScript",
    "topic": "Типы данных",
    "level": "low",
    "question": "Что значит null и undefined в JavaScript?",
    "answer": "null - просто специальное значение, которое представляет собой «ничего», «пусто» или «значение неизвестно». undefined означает, что «значение не было присвоено»."
    }, 
    {"id": 9,
    "block": "Основы JavaScript",
    "topic": "Типы данных",
    "level": "low",
    "question": "Какие существуют примитивные типы? Почему они так называются?",
    "answer": "number, BigInt, boolean, string, null, undefined. типы называются «примитивными», потому что их значениями могут быть только простые значения (будь то строка, или число, или что-то ещё)/"
    }, 
    {"id": 10,
    "block": "Основы JavaScript",
    "topic": "Типы данных",
    "level": "low",
    "question": "Как получить тип аргумента?",
    "answer": "C помощью оператора typeof."
    }, 
    {"id": 11,
    "block": "Основы JavaScript",
    "topic": "Типы данных",
    "level": "low",
    "question": "Почему typeof(null) возвращает “object”?",
    "answer": "Это официально признанная ошибка в typeof, ведущая начало с времён создания JavaScript и сохранённая для совместимости. Конечно, null не является объектом. Это специальное значение с отдельным типом."
    }, 
    {"id": 12,
    "block": "Основы JavaScript",
    "topic": "Взаимодействие: alert, prompt, confirm",
    "level": "low",
    "question": "Что такое модальное окно?",
    "answer": "Понятие модальное означает, что пользователь не может взаимодействовать с интерфейсом остальной части страницы, нажимать на другие кнопки и т.д. до тех пор, пока взаимодействует с окном."
    }, 
    {"id": 13,
    "block": "Основы JavaScript",
    "topic": "Взаимодействие: alert, prompt, confirm",
    "level": "low",
    "question": "Что возвращает вызов prompt? Какие аргументы принимает prompt?",
    "answer": "Вызов prompt возвращает текст, указанный в поле для ввода, или null, если ввод отменён пользователем. prompt(title, [default]);",
    "description": ["title - текст для отображения в окне", "default - необязательный второй параметр, который устанавливает начальное значение в поле для текста в окне."]
    }, 
    {"id": 14,
    "block": "Основы JavaScript",
    "topic": "Взаимодействие: alert, prompt, confirm",
    "level": "low",
    "question": "Какие есть особенности использования prompt в IE?",
    "answer": "Для IE всегда устанавливайте значение по умолчанию: Второй параметр является необязательным, но если не указать его, то Internet Explorer вставит строку 'undefined' в поле для ввода."
    }, 
    {"id": 15,
    "block": "Основы JavaScript",
    "topic": "Взаимодействие: alert, prompt, confirm",
    "level": "low",
    "question": "Что отображает функция confirm? Что она возвращает?",
    "answer": "Функция confirm отображает модальное окно с текстом вопроса question и двумя кнопками: OK и Отмена. Результат – true, если нажата кнопка OK. В других случаях – false."
    }, 
    {"id": 16,
    "block": "Основы JavaScript",
    "topic": "Взаимодействие: alert, prompt, confirm",
    "level": "low",
    "question": "Как изменить внешний вид модальных окон?",
    "answer": "Никак. Единственный способ использовать кастомный дизайн - создать своё 'модальное' окно."
    }, 
    {"id": 17,
    "block": "Основы JavaScript",
    "topic": "Преобразование типов данных",
    "level": "low",
    "question": "Какие есть способы преобразования значения к строке?",
    "answer": "String(value), value.toString()"
    }, 
    {"id": 18,
    "block": "Основы JavaScript",
    "topic": "Преобразование типов данных",
    "level": "low",
    "question": "Какие есть способы преобразования значения к числу?",
    "answer": "+value, Number(value)"
    }, 
    {"id": 19,
    "block": "Основы JavaScript",
    "topic": "Преобразование типов данных",
    "level": "low",
    "question": "Что выведет Number(undefined)?",
    "answer": "NaN"
    }, 
    {"id": 20,
    "block": "Основы JavaScript",
    "topic": "Преобразование типов данных",
    "level": "low",
    "question": "Что выведет Number(null)?",
    "answer": "0"
    }, 
    {"id": 21,
    "block": "Основы JavaScript",
    "topic": "Преобразование типов данных",
    "level": "low",
    "question": "Как преобразовать значение к логическому типу?",
    "answer": "Boolean(value)"
    }, 
    {"id": 22,
    "block": "Основы JavaScript",
    "topic": "Преобразование типов данных",
    "level": "low",
    "question": "Какие значения при преобразовании к boolean становятся false? Назвать 5 примеров",
    "answer": "0, null, undefined, NaN, ''"
    }
    , 
    {"id": 23,
    "block": "Основы JavaScript",
    "topic": "Базовые операторы, математика",
    "level": "low",
    "question": "Как получить корень числа в JavaScript?",
    "answer": "value ** (1/2)"
    },  
    {"id": 24,
    "block": "Основы JavaScript",
    "topic": "Базовые операторы, математика",
    "level": "low",
    "question": "Как работает бинарный плюс со строками?",
    "answer": "Если бинарный оператор '+' применить к строкам, то он их объединяет в одну строку"
    }, 
    {"id": 25,
    "block": "Основы JavaScript",
    "topic": "Базовые операторы, математика",
    "level": "low",
    "question": "Какой будет результат выражения '1' + 2? А если такое: 2 + 2 + '1'",
    "answer": "12"
    }, 
    {"id": 26,
    "block": "Основы JavaScript",
    "topic": "Базовые операторы, математика",
    "level": "low",
    "question": "Какие побитовые операции существуют? Назвать 7 операций",
    "answer": ["AND(и) ( & )",
        "OR(или) ( | )",
        "XOR(побитовое исключающее или) ( ^ )",
        "NOT(не) ( ~ )",
       "LEFT SHIFT(левый сдвиг) ( << )",
        "RIGHT SHIFT(правый сдвиг) ( >> )",
        "ZERO-FILL RIGHT SHIFT(правый сдвиг с заполнением нулями) ( >>> )"
        ]
    }
    , 
    {"id": 27,
    "block": "Основы JavaScript",
    "topic": "Операторы сравнения",
    "level": "low",
    "question": "Каков алгоритм сравнения двух строк? ",
    "answer": ["Сначала сравниваются первые символы строк.", "Если первый символ первой строки больше (меньше), чем первый символ второй, то первая строка больше (меньше) второй. Сравнение завершено.", "Если первые символы равны, то таким же образом сравниваются уже вторые символы строк.", "Сравнение продолжается, пока не закончится одна из строк.", "Если обе строки заканчиваются одновременно, то они равны. Иначе, большей считается более длинная строка."]
}
    , 
    {"id": 28,
    "block": "Основы JavaScript",
    "topic": "Условное ветвление",
    "level": "low",
    "question": "Что такое тернарный оператор? Какой синтаксис?",
    "answer": "Условный оператор, позволяющий записывать условия короче, чем конструкция if(…) let result = условие ? значение1 : значение2;"
    }
    , 
    {"id": 29,
    "block": "Основы JavaScript",
    "topic": "Логические операторы",
    "level": "low",
    "question": "Как работает логический оператор ИЛИ?",
    "answer": ["Вычисляет операнды слева направо.", "Каждый операнд конвертирует в логическое значение. Если результат true, останавливается и возвращает исходное значение этого операнда.", "Если все операнды являются ложными (false), возвращает последний из них."]
    } , 
    {"id": 30,
    "block": "Основы JavaScript",
    "topic": "Логические операторы",
    "level": "low",
    "question": "Как работает логический оператор И?",
    "answer": ["Вычисляет операнды слева направо.", "Каждый операнд преобразует в логическое значение. Если результат false, останавливается и возвращает исходное значение этого операнда.", "Если все операнды были истинными, возвращается последний."]
    } , 
    {"id": 31,
    "block": "Основы JavaScript",
    "topic": "Логические операторы",
    "level": "low",
    "question": "Как работает логический оператор НЕ?",
    "answer": "Сначала приводит аргумент к логическому типу true/false. Затем возвращает противоположное значение."
    } , 
    {"id": 32,
    "block": "Основы JavaScript",
    "topic": "Логические операторы",
    "level": "low",
    "question": "В какой последовательности идут приоритеты логических операторов НЕ (!), И (&&), ИЛИ (||) от низкого приоритета к высокому?",
    "answer": "у ИЛИ самый низкий приоритет, у НЕ самый высокий. То есть, ИЛИ, И, НЕ"
    }
    , 
    {"id": 33,
    "block": "Основы JavaScript",
    "topic": "Оператор объединения с null",
    "level": "low",
    "question": "Что такое оператор объединения с null? По какой схеме работает?",
    "answer": "Представляет собой два вопросительных знака. Схема работы: оператор ?? возвращает первый аргумент, если он не null/undefined, иначе второй."
    }  , 
    {"id": 34,
    "block": "Основы JavaScript",
    "topic": "Оператор объединения с null",
    "level": "low",
    "question": "Какая разница между операторами «??» и «| |» ?",
    "answer": "ИЛИ возвращает истинное значение, а ?? определённое значение"
    }  , 
    {"id": 35,
    "block": "Основы JavaScript",
    "topic": "Оператор объединения с null",
    "level": "low",
    "question": "Какая будет ошибка в выражении let x = 1 && 2 ?? 3; ? Почему она появляется? Как её обойти?",
    "answer": "Синтаксическая ошибка, т.к. запрещено использовать оператор объединения с null вместе с операторами ||, &&. Обойти это ограничение можно если поставить скобки вокруг выражения с ??"
    }
    , 
    {"id": 36,
    "block": "Основы JavaScript",
    "topic": "Циклы while и for",
    "level": "low",
    "question": "Что такое итерация?",
    "answer": "Одно выполнение тела цикла"
    }, 
    {"id": 37,
    "block": "Основы JavaScript",
    "topic": "Циклы while и for",
    "level": "low",
    "question": "Что делает директива break?",
    "answer": "Директива break полностью прекращает выполнение цикла и передаёт управление на строку за его телом, то есть на alert."
    }, 
    {"id": 38,
    "block": "Основы JavaScript",
    "topic": "Циклы while и for",
    "level": "low",
    "question": "Что делает директива continue?",
    "answer": "Директива continue – «облегчённая версия» break. При её выполнении цикл не прерывается, а переходит к следующей итерации (если условие все ещё равно true)."
    }, 
    {"id": 39,
    "block": "Основы JavaScript",
    "topic": "Циклы while и for",
    "level": "low",
    "question": "Как создаётся метка в цикле? Зачем она нужна?",
    "answer": "Метка имеет вид идентификатора с двоеточием перед циклом. Используется для выхода одновременно из нескольких уровней цикла сразу."
    }
    , 
    {"id": 40,
    "block": "Основы JavaScript",
    "topic": "Конструкция switch",
    "level": "low",
    "question": "Что есть в конструкции switch?",
    "answer": "Конструкция switch имеет один или более блок case и необязательный блок default."
    }, 
    {"id": 41,
    "block": "Основы JavaScript",
    "topic": "Function Expression",
    "level": "low",
    "question": "В чём отличие Function Expression от Function Declaration?",
    "answer": ["- Function Declaration: функция объявляется отдельной конструкцией «function…» в основном потоке кода.", "- Function Expression: функция, созданная внутри другого выражения или синтаксической конструкции. В данном случае функция создаётся в правой части «выражения присваивания» =", "- Function Expression создаётся, когда выполнение доходит до него, и затем уже может использоваться."]
    } , 
    {"id": 42,
    "block": "Качество кода",
    "topic": "",
    "level": "low",
    "question": "Что такое отладка?",
    "answer": "Процесс поиска и исправления ошибок в скрипте"
    } , 
    {"id": 43,
    "block": "Качество кода",
    "topic": "",
    "level": "low",
    "question": "Сколько есть способов приостановить выполнение скрипта? Какие это способы?",
    "answer": ["3", "Точками останова.", "Использованием в коде команды debugger.", "При ошибке (если инструменты разработчика открыты и опция включена)."]
}
    , 
    {"id": 44,
    "block": "Объекты: основы",
     "topic": "Объекты",
    "level": "low",
    "question": "Для чего используются объекты?",
    "answer": "Для хранения коллекций различных значений и более сложных сущностей"
    }, 
    {"id": 45,
    "block": "Объекты: основы",
     "topic": "Объекты",
    "level": "low",
    "question": "Какой оператор используется для удаления свойства из объекта?",
    "answer": "delete. Например: delete user.age;"
    }, 
    {"id": 46,
    "block": "Объекты: основы",
     "topic": "Объекты",
    "level": "low",
    "question": "Как получить доступ к значению, имя которого состоит из нескольких слов?",
    "answer": "obj['some prop name'] = true;"
    }, 
    {"id": 47,
    "block": "Объекты: основы",
     "topic": "Объекты",
    "level": "medium",
    "question": "Какое значение можно установить в свойство __proto__ ?",
    "answer": "Только объектное"
    }, 
    {"id": 48,
    "block": "Объекты: основы",
     "topic": "Объекты",
    "level": "low",
    "question": "Как проверить существование свойства в объекте?",
    "answer": "С помощью оператора in"
    }
    , 
    {"id": 49,
    "block": "Объекты: основы",
     "topic": "Копирование объектов и ссылки",
    "level": "low",
    "question": "Что хранит в себе переменная, которой был присвоен объект?",
    "answer": "Переменная хранит его «адрес в памяти», другими словами «ссылку» на него."
    }, 
    {"id": 50,
    "block": "Объекты: основы",
     "topic": "Копирование объектов и ссылки",
    "level": "low",
    "question": "Что делает метод Object.assign? Какой синтаксис?",
    "answer": ["Object.assign(dest, [src1, src2, src3...])", "Первый аргумент dest — целевой объект.", "Остальные аргументы src1, ..., srcN (может быть столько, сколько нужно) являются исходными объектами", "Метод копирует свойства всех исходных объектов src1, ..., srcN в целевой объект dest. То есть, свойства всех перечисленных объектов, начиная со второго, копируются в первый объект.", "Возвращает объект dest.", "С помощью него можно склонировать объект или объединить несколько объектов в один новый."]
}
    , 
    {"id": 51,
    "block": "Объекты: основы",
     "topic": "Сборка мусора",
    "level": "medium",
    "question": "Какой принцип является основной концепцией управления памятью в JavaScript?",
    "answer": "Принцип достижимости."
    },
    {"id": 52,
    "block": "Объекты: основы",
     "topic": "Сборка мусора",
    "level": "low",
    "question": "Что делает фоновый процесс «сборщик мусора» в JavaScript?",
    "answer": "Он следит за всеми объектами и удаляет те, которые стали недостижимы.;"
    },
    {"id": 53,
    "block": "Объекты: основы",
     "topic": "Копирование объектов и ссылки",
    "level": "medium",
    "question": "Как сделать глубокое клонирование?",
    "answer": "С помощью рекурсии или использовать готовую реализацию - метод _.cloneDeep(obj) из JavaScript-библиотеки lodash."
    },
    {"id": 54,
    "block": "Объекты: основы",
     "topic": "Сборка мусора",
    "level": "medium",
    "question": "Какой алгоритм использует сборщик мусора в JavaScript? Как этот алгоритм работает?",
    "answer": ["Основной алгоритм сборки мусора – «алгоритм пометок» (англ. «mark-and-sweep»).", "Согласно этому алгоритму, сборщик мусора регулярно выполняет следующие шаги:", "Сборщик мусора «помечает» (запоминает) все корневые объекты.", "Затем он идёт по их ссылкам и помечает все найденные объекты.", "Затем он идёт по ссылкам помеченных объектов и помечает объекты, на которые есть ссылка от них. Все объекты запоминаются, чтобы в будущем не посещать один и тот же объект дважды.", "…И так далее, пока не будут посещены все ссылки (достижимые от корней).", "Все непомеченные объекты удаляются."]
}
    ,
    {"id": 55,
    "block": "Объекты: основы",
     "topic": "Методы объекта, “this”",
    "level": "low",
    "question": "Для чего нужно ключевое слово this? ",
    "answer": "Для доступа к информации внутри объекта метод может использовать ключевое слово this."
    },
    {"id": 56,
    "block": "Объекты: основы",
     "topic": "Методы объекта, “this”",
    "level": "medium",
    "question": "Что такое Reference Type? ",
    "answer": ["Специальное значение «ссылочного типа». Значение ссылочного типа – это «триплет»: комбинация из трёх значений (base, name, strict), где:", "base – это объект.", "name – это имя свойства объекта.", "strict – это режим исполнения. Является true, если действует строгий режим (use strict)."]
},
    {"id": 57,
    "block": "Объекты: основы",
     "topic": "Методы объекта, “this”",
    "level": "low",
    "question": "Когда определяется значение this?",
    "answer": "Во время исполнения кода"
    }

    ,
    {"id": 58,
    "block": "Объекты: основы",
     "topic": "Конструкторы, создание объектов через “new”",
    "level": "low",
    "question": "Чем отличается функция-конструктор от обычной функции?",
    "answer": "Ничем, это обычная функция, НО есть два соглашения: Имя функции-конструктора должно начинаться с большой буквы. Функция-конструктор должна вызываться при помощи оператора 'new'."
    } ,
    {"id": 59,
    "block": "Объекты: основы",
     "topic": "Конструкторы, создание объектов через “new”",
    "level": "low",
    "question": "Что происходит, когда функция вызывается через new?",
    "answer": "Создаётся новый пустой объект, и он присваивается this. Выполняется код функции. Обычно он модифицирует this, добавляет туда новые свойства. Возвращается значение this."
    } ,
    {"id": 60,
    "block": "Объекты: основы",
     "topic": "Конструкторы, создание объектов через “new”",
    "level": "high",
    "question": "Для чего нужно свойство new.target? Какие значения в нём могут быть?",
    "answer": "Используя специальное свойство new.target внутри функции, мы можем проверить, вызвана ли функция при помощи оператора new или без него.  В случае, если функция вызвана при помощи new, то в new.target будет сама функция, в противном случае undefined."
    } ,
    {"id": 61,
    "block": "Объекты: основы",
     "topic": "Конструкторы, создание объектов через “new”",
    "level": "high",
    "question": "Что возвращается функция-конструктор?",
    "answer": "При вызове return с объектом, будет возвращён объект, а не this. При вызове return с примитивным значением, примитивное значение будет отброшено."
    }

    ,
    {"id": 62,
    "block": "Объекты: основы",
     "topic": "Опциональная цепочка “?.”",
    "level": "low",
    "question": "Что такое опциональная цепочка?",
    "answer": "Опциональная цепочка ?. — синтаксическая конструкция, это безопасный способ доступа к свойствам вложенных объектов, даже если какое-либо из промежуточных свойств не существует."
    }

    ,
    {"id": 63,
    "block": "Объекты: основы",
     "topic": "Тип данных Symbol",
    "level": "low",
    "question": "Что такое Symbol? Как его создать?",
    "answer": "Символ (symbol) – примитивный тип данных, использующийся для создания уникальных идентификаторов. Создаются новые символы с помощью функции Symbol(). Так же, при создании символу можно дать описание (также называемое имя), в основном использующееся для отладки кода"
    },
    {"id": 64,
    "block": "Объекты: основы",
     "topic": "Тип данных Symbol",
    "level": "low",
    "question": "Каким будет результат сравнения id1 == id2? Почему? 1) let id1 = Symbol('id');   2)let id2 = Symbol('id');",
    "answer": "false, т.к. символы гарантированно уникальны. Даже если мы создадим множество символов с одинаковым описанием, это всё равно будут разные символы. Описание – это просто метка, которая ни на что не влияет."
    },
    {"id": 65,
    "block": "Объекты: основы",
     "topic": "Тип данных Symbol",
    "level": "low",
    "question": "К какому свойству необходимо обратиться для получения описания Symbol?",
    "answer": "description"
    },
    {"id": 66,
    "block": "Объекты: основы",
     "topic": "Тип данных Symbol",
    "level": "medium",
    "question": "Почему Object.keys() и цикл for..in не обрабатывают свойства, чьи ключи являются Symbol?",
    "answer": "Это – часть общего принципа «сокрытия символьных свойств». Если другая библиотека или скрипт будут работать с нашим объектом, то при переборе они не получат ненароком наше символьное свойство."
    },
    {"id": 67,
    "block": "Объекты: основы",
     "topic": "Тип данных Symbol",
    "level": "medium",
    "question": "Копирует ли символьные свойства Object.assign?",
    "answer": "Да"
    },
    {"id": 68,
    "block": "Объекты: основы",
     "topic": "Тип данных Symbol",
    "level": "medium",
    "question": "Зачем нужен глобальный реестр символов? Как получить из него символ?",
    "answer": "Реестр нужен для создания и хранения символов, к которым можно будет обратиться позже. Для чтения (или, при отсутствии, создания) символа из реестра используется вызов Symbol.for(key)"
    },
    {"id": 69,
    "block": "Объекты: основы",
     "topic": "Тип данных Symbol",
    "level": "medium",
    "question": "С помощью какого метода можно получить имя глобального символа?",
    "answer": "Symbol.keyFor(sym)"
    }

    ,
    {"id": 70,
    "block": "Объекты: основы",
     "topic": "Преобразование объектов в примитивы",
    "level": "low",
    "question": "Что происходит когда мы пытаемся вызвать метод у примитива?",
    "answer": "Чтобы это работало, при таком доступе создаётся специальный «объект-обёртка», который предоставляет нужную функциональность, а после удаляется."
    },
    {"id": 71,
    "block": "Объекты: основы",
     "topic": "Преобразование объектов в примитивы",
    "level": "low",
    "question": "Какие методы имеют null/undefined?",
    "answer": "null/undefined не имеют методов. У них нет соответствующих «объектов-обёрток», и они не имеют никаких методов."
    }

    ,
    {"id": 72,
    "block": "Объекты: основы",
     "topic": "Массивы",
    "level": "low",
    "question": "Что такое массив? Какие есть варианты объявления массива?",
    "answer": ["Упорядоченная коллекция данных. В JavaScript – особый вид объекта", "let arr = new Array();", "let arr = [];"]
},
    {"id": 73,
    "block": "Объекты: основы",
     "topic": "Массивы",
    "level": "medium",
    "question": "Что такое очередь?",
    "answer": ["Структура данных - упорядоченная коллекция данных, поддерживающая два вида операций:", "push добавляет элемент в конец.", "shift удаляет элемент в начале, сдвигая очередь, так что второй элемент становится первым."]
},
    {"id": 74,
    "block": "Объекты: основы",
     "topic": "Массивы",
    "level": "medium",
    "question": "Что такое стек?",
    "answer": ["Структура данных, поддерживающая два вида операций:", "push добавляет элемент в конец.", "pop удаляет последний элемент."]
},
    {"id": 75,
    "block": "Объекты: основы",
     "topic": "Массивы",
    "level": "medium",
    "question": "Что такое двусторонняя очередь?",
    "answer": "Структура данных, позволяющая работать и как очередь и как стек (добавлять/удалять элементы как в начале, так и в конце массива)"
    },
    {"id": 76,
    "block": "Объекты: основы",
     "topic": "Массивы",
    "level": "low",
    "question": "Какой цикл лучше использовать для перебора свойств массива?",
    "answer": "for..of"
    },
    {"id": 77,
    "block": "Объекты: основы",
     "topic": "Массивы",
    "level": "low",
    "question": "Для чего используется синтаксис new Array()? Какие аргументы принимает?",
    "answer": "Для создания массива заданной длины. Принимает в аргумент число, которое и является длинной массива"
    }

    ,
    {"id": 78,
    "block": "Объекты: основы",
     "topic": "Методы массивов",
    "level": "low",
    "question": "Что делает метод splice? Какой синтаксис?",
    "answer": ["Метод arr.splice(str) – это универсальный «швейцарский нож» для работы с массивами. Умеет всё: добавлять, удалять и заменять элементы.", "arr.splice(index[, deleteCount, elem1, ..., elemN])", "Он начинает с позиции index, удаляет deleteCount элементов и вставляет elem1, ..., elemN на их место. Возвращает массив из удалённых элементов."]
},
    {"id": 79,
    "block": "Объекты: основы",
     "topic": "Методы массивов",
    "level": "low",
    "question": ["Что делает метод splice? Какой синтаксис?", "Он возвращает новый массив, в который копирует элементы, начиная с индекса start и до end (не включая end).", "arr.slice([start], [end])", "Можно вызвать slice и вообще без аргументов: arr.slice() создаёт копию массива arr."]
},
    {"id": 80,
    "block": "Объекты: основы",
     "topic": "Методы массивов",
    "level": "low",
    "question": "Что делает метод concat? Какой синтаксис?",
    "answer": ["Метод arr.concat создаёт новый массив, в который копирует данные из других массивов и дополнительные значения.", "arr.concat(arg1, arg2...)", "Он принимает любое количество аргументов, которые могут быть как массивами, так и простыми значениями.", "В результате мы получаем новый массив, включающий в себя элементы из arr, а также arg1, arg2 и так далее…"]
},
    {"id": 81,
    "block": "Объекты: основы",
     "topic": "Методы массивов",
    "level": "low",
    "question": "Что делает forEach? Какой синтаксис?",
    "answer": ["Метод arr.forEach позволяет запускать функцию для каждого элемента массива.", "arr.forEach(function(item, index, array) { ... });"]
},
    {"id": 82,
    "block": "Объекты: основы",
     "topic": "Методы массивов",
    "level": "low",
    "question": "Что делает arr.indexOf? Какой полный синтаксис?",
    "answer": "arr.indexOf(item, from) ищет item, начиная с индекса from, и возвращает индекс, на котором был найден искомый элемент, в противном случае -1."
    },
    {"id": 83,
    "block": "Объекты: основы",
     "topic": "Методы массивов",
    "level": "low",
    "question": "Что делает arr.lastIndexOf? Какой полный синтаксис?",
    "answer": "arr.lastIndexOf(item, from) – то же самое, но ищет справа налево."
    },
    {"id": 84,
    "block": "Объекты: основы",
     "topic": "Методы массивов",
    "level": "low",
    "question": "Что делает arr.includes? Какой полный синтаксис?",
    "answer": "arr.includes(item, from) – ищет item, начиная с индекса from, и возвращает true, если поиск успешен."
    },
    {"id": 85,
    "block": "Объекты: основы",
     "topic": "Методы массивов",
    "level": "low",
    "question": "Что делает метод find? Какой полный синтаксис? Чем findIndex отличается от find?",
    "answer": ["Находит объект с определённым условием. Если true - возвращается текущий элемент и перебор прерывается, если если все итерации оказались ложными, возвращается undefined.", "arr.find(function(item, index, array) { ... });", "Функция вызывается по очереди для каждого элемента массива:", "item – очередной элемент.", "index – его индекс.", "array – сам массив.", "Метод arr.findIndex – по сути, то же самое, но возвращает индекс, на котором был найден элемент, а не сам элемент, и -1, если ничего не найдено."]
},
    {"id": 86,
    "block": "Объекты: основы",
     "topic": "Методы массивов",
    "level": "low",
    "question": "Что делает метод filter? Какой полный синтаксис?",
    "answer": ["Возвращает массив из всех подходящих по условию элементов. Если true - элемент добавляется к результату, и перебор продолжается. Возвращается пустой массив в случае, если ничего не найдено.", "arr.filter(function(item, index, array) { ... });"]
},
    {"id": 87,
    "block": "Объекты: основы",
     "topic": "Методы массивов",
    "level": "low",
    "question": "Что делает map? Какой полный синтаксис?",
    "answer": ["Он вызывает функцию для каждого элемента массива и возвращает массив результатов выполнения этой функции.", "arr.map(function(item, index, array) { ... });"]
},
    {"id": 88,
    "block": "Объекты: основы",
     "topic": "Методы массивов",
    "level": "low",
    "question": "Что делает этот метод split? Какие аргументы принимает?",
    "answer": "Он разбивает строку на массив по заданному разделителю. Принимает аргумент разделителя, а так же у метода split есть необязательный второй числовой аргумент – ограничение на количество элементов в массиве. Если их больше, чем указано, то остаток массива будет отброшен."
    },
    {"id": 89,
    "block": "Объекты: основы",
     "topic": "Методы массивов",
    "level": "low",
    "question": "Какой синтаксис метода join? Что он делает?",
    "answer": "arr.join(glue). Он создаёт строку из элементов arr, вставляя glue между ними."
    },
    {"id": 90,
    "block": "Объекты: основы",
     "topic": "Методы массивов",
    "level": "low",
    "question": "Что делают методы reduce/reduceRight? Какой синтаксис? В чём их отличие?",
    "answer": ["Они используются для вычисления какого-нибудь единого значения на основе всего массива.", "arr.reduce(function(previousValue, item, index, array) { ... }, [initial]);", "Функция применяется по очереди ко всем элементам массива и «переносит» свой результат на следующий вызов.", "Аргументы:", "previousValue – результат предыдущего вызова этой функции, равен initial при первом вызове (если передан initial),", "item – очередной элемент массива,", "index – его индекс,", "array – сам массив.", "При вызове функции результат её вызова на предыдущем элементе массива передаётся как первый аргумент.", "Отличие reduceRight от reduce в том, что он проходит по массиву справа налево."]
},
    {"id": 91,
    "block": "Объекты: основы",
     "topic": "Методы массивов",
    "level": "low",
    "question": "Что такое thisArg?",
    "answer": "Необязательный параметр, который принимает большинство методов массивов. Значение параметра thisArg становится this для func."
    }

    ,
    {"id": 92,
    "block": "Объекты: основы",
     "topic": "Перебираемые объекты",
    "level": "low",
    "question": "Что такое перебираемые объекты?",
    "answer": "Это концепция, которая позволяет использовать любой объект в цикле for..of."
    },
    {"id": 93,
    "block": "Объекты: основы",
     "topic": "Перебираемые объекты",
    "level": "medium",
    "question": "Что нужно сделать, чтобы объект стал итерируемым?",
    "answer": "Нужно добавить в объект метод с именем Symbol.iterator"
    }

    ,
    {"id": 94,
    "block": "Типы данных",
     "topic": "Map и Set",
    "level": "medium",
    "question": "Что такое Map? Чем отличается от Object?",
    "answer": ["Map – это коллекция ключ/значение, как и Object. Но основное отличие в том, что Map позволяет использовать ключи любого типа.", "Что угодно может быть ключом, в том числе и объекты.", "Есть дополнительные методы, свойство size."]
    } ,
    {"id": 95,
    "block": "Типы данных",
     "topic": "Map и Set",
    "level": "medium",
    "question": "Какие существуют методы и свойства Map?",
    "answer": [
        "new Map() – создаёт коллекцию.",
        "map.set(key, value) – записывает по ключу key значение value.",
        "map.get(key) – возвращает значение по ключу или undefined, если ключ key отсутствует.",
        "map.has(key) – возвращает true, если ключ key присутствует в коллекции, иначе false.",
        "map.delete(key) – удаляет элемент по ключу key.",
        "map.clear() – очищает коллекцию от всех элементов.",
        "map.size – возвращает текущее количество элементов."
    ]
    } ,
    {"id": 96,
    "block": "Типы данных",
     "topic": "Map и Set",
    "level": "medium",
    "question": "Может ли Map использовать объекты в качестве ключей?",
    "answer": "Да"
    } ,
    {"id": 97,
    "block": "Типы данных",
     "topic": "Map и Set",
    "level": "medium",
    "question": "Как объект Map сравнивает ключи?",
    "answer": "Map использует алгоритм SameValueZero. Это почти такое же сравнение, что и ===, с той лишь разницей, что NaN считается равным NaN. Так что NaN также может использоваться в качестве ключа. Этот алгоритм не может быть заменён или модифицирован."
    } ,
    {"id": 98,
    "block": "Типы данных",
     "topic": "Map и Set",
    "level": "medium",
    "question": "Что возвращает вызов map.set()?",
    "answer": "Объект map"
    } ,
    {"id": 99,
    "block": "Типы данных",
     "topic": "Map и Set",
    "level": "medium",
    "question": "Для чего нужны методы map.keys(), map.values(), map.entries() и что они возвращают?",
    "answer": ["map.keys() – возвращает итерируемый объект по ключам", "map.values() – возвращает итерируемый объект по значениям", "map.entries() – возвращает итерируемый объект по парам вида [ключ, значение], этот вариант используется по умолчанию в for..of"]
    } ,
    {"id": 100,
    "block": "Типы данных",
     "topic": "Map и Set",
    "level": "medium",
    "question": "В каком порядке происходит перебор Map?",
    "answer": "В отличие от обычных объектов Object, в Map перебор происходит в том же порядке, в каком происходило добавление элементов."
    } ,
    {"id": 101,
    "block": "Типы данных",
     "topic": "Map и Set",
    "level": "medium",
    "question": "Что делает метод Object.entries(obj)?",
    "answer": "Получает объект и возвращает массив пар ключ-значение для Map в том формате, чтобы можно было создать коллекцию из объекта. Н-р, let map = new Map(Object.entries(obj))"
    } ,
    {"id": 102,
    "block": "Типы данных",
     "topic": "Map и Set",
    "level": "medium",
    "question": "Что делает метод Object.fromEntries ?",
    "answer": ["Получив массив пар вида [ключ, значение], он создаёт из них объект", "Н-р, let obj = Object.fromEntries(map.entries()); или let obj = Object.fromEntries(map);", "Это то же самое, так как Object.fromEntries ожидает перебираемый объект в качестве аргумента, не обязательно массив. А перебор map как раз возвращает пары ключ/значение, так же, как и map.entries(). Так что в итоге у нас будет обычный объект с теми же ключами/значениями, что и в map."]
    } ,
    {"id": 103,
    "block": "Типы данных",
     "topic": "Map и Set",
    "level": "medium",
    "question": "Что такое Set?",
    "answer": "Особый вид коллекции: «множество» значений (без ключей), где каждое значение может появляться только один раз."
    } ,
    {"id": 104,
    "block": "Типы данных",
     "topic": "Map и Set",
    "level": "medium",
    "question": "Какие есть основные методы у Set?",
    "answer": ["new Set(iterable) – создаёт Set, и если в качестве аргумента был предоставлен итерируемый объект (обычно это массив), то копирует его значения в новый Set.", "set.add(value) – добавляет значение (если оно уже есть, то ничего не делает), возвращает тот же объект set.", "set.delete(value) – удаляет значение, возвращает true, если value было в множестве на момент вызова, иначе false.", "set.has(value) – возвращает true, если значение присутствует в множестве, иначе false.", "set.clear() – удаляет все имеющиеся значения.", "set.size – возвращает количество элементов в множестве."]
    } ,
    {"id": 105,
    "block": "Типы данных",
     "topic": "Map и Set",
    "level": "medium",
    "question": "Что произойдёт если вызвать set.add() два раза с одним и тем же значением?",
    "answer": "Ничего: за счёт этого каждое значение появляется один раз."
    } ,
    {"id": 106,
    "block": "Типы данных",
     "topic": "Map и Set",
    "level": "medium",
    "question": "Какая есть альтернатива множеству Set? Почему лучше использовать Set вместо этого?",
    "answer": "Альтернативой множеству Set может выступать массив для хранения гостей и дополнительный код для проверки уже имеющегося элемента с помощью arr.find. Но в этом случае будет хуже производительность, потому что arr.find проходит весь массив для проверки наличия элемента. Множество Set лучше оптимизировано для добавлений, оно автоматически проверяет на уникальность."
    } ,
    {"id": 107,
    "block": "Типы данных",
     "topic": "Map и Set",
    "level": "medium",
    "question": "Какие есть варианты перебора множества Set?",
    "answer": "Мы можем перебрать содержимое объекта set как с помощью метода for..of, так и используя forEach"
    } ,
    {"id": 108,
    "block": "Типы данных",
     "topic": "Map и Set",
    "level": "medium",
    "question": "Какие встроенные методы есть у Set?",
    "answer": ["Все те же, что и у Map. entries.keys() – для совместимости с Map, entries.values() - возвращает перебираемый объект для значений.",
        "new Set() – создаёт коллекцию.",
        "set.set(key, value) – записывает по ключу key значение value.",
        "set.get(key) – возвращает значение по ключу или undefined, если ключ key отсутствует.",
        "set.has(key) – возвращает true, если ключ key присутствует в коллекции, иначе false.",
        "set.delete(key) – удаляет элемент по ключу key.",
        "set.clear() – очищает коллекцию от всех элементов.",
        "set.size – возвращает текущее количество элементов."
    ] } ,
    {"id": 109,
    "block": "Типы данных",
     "topic": "Map и Set",
    "level": "medium",
    "question": "Можно ли поменять порядок элементов или получить элемент напрямую по его номеру?",
    "answer": "Нет"
    }

    ,
    {"id": 110,
    "block": "Типы данных",
     "topic": "WeakMap and WeakSet",
    "level": "medium",
    "question": "Какие отличия WeakMap от Map?",
    "answer": ["- в WeakMap должны быть объектами, а не примитивными значениями, иначе будет ошибка", "- WeakMap не поддерживает перебор и методы keys(), values(), entries(), так что нет способа взять все ключи или значения из неё."]
    } ,
    {"id": 111,
    "block": "Типы данных",
     "topic": "WeakMap and WeakSet",
    "level": "medium",
    "question": "Какие методы существуют в WeakMap и WeakSet?",
    "answer": ["weakMap.get(key)", "weakMap.set(key, value)", "weakMap.delete(key)", "weakMap.has(key)"]
    } ,
    {"id": 112,
    "block": "Типы данных",
     "topic": "WeakMap and WeakSet",
    "level": "medium",
    "question": "Почему для структуры WeakMap и WeakSet существует ограниченное количество методов? Какие методы не входят в их число?",
    "answer": ["Из-за особенностей технической реализации. Если объект станет недостижим, то он будет автоматически удалён сборщиком мусора. Но нет информации, в какой момент произойдёт эта очистка.", "Решение о том, когда делать сборку мусора, принимает движок JavaScript. Он может посчитать необходимым как удалить объект прямо сейчас, так и отложить эту операцию, чтобы удалить большее количество объектов за раз позже. Так что технически количество элементов в коллекции WeakMap неизвестно. Движок может произвести очистку сразу или потом, или сделать это частично. По этой причине методы для доступа ко всем сразу ключам/значениям недоступны.", "Наборы keys(), values(), entries() не поддерживаются."]
    } ,
    {"id": 113,
    "block": "Типы данных",
     "topic": "WeakMap and WeakSet",
    "level": "medium",
    "question": "Зачем используют WeakMap?",
    "answer": ["В основном, WeakMap используется в качестве дополнительного хранилища данных. Если мы работаем с объектом, который «принадлежит» другому коду, может быть даже сторонней библиотеке, и хотим сохранить у себя какие-то данные для него, которые должны существовать лишь пока существует этот объект, то WeakMap – как раз то, что нужно.", "Мы кладём эти данные в WeakMap, используя объект как ключ, и когда сборщик мусора удалит объекты из памяти, ассоциированные с ними данные тоже автоматически исчезнут.", "Другая частая сфера применения – это кеширование, когда результат вызова функции должен где-то запоминаться («кешироваться») для того, чтобы дальнейшие её вызовы на том же объекте могли просто брать уже готовый результат, повторно используя его."]
    } ,
    {"id": 114,
    "block": "Типы данных",
     "topic": "WeakMap and WeakSet",
    "level": "medium",
    "question": "Для чего нужна коллекция WeakSet?",
    "answer": ["Будучи «слабой» версией оригинальной структуры данных, она тоже служит в качестве дополнительного хранилища. Но не для произвольных данных, а скорее для значений типа «да/нет». Присутствие во множестве WeakSet может что-то сказать нам об объекте.", "Например, мы можем добавлять пользователей в WeakSet для учёта тех, кто посещал наш сайт"]
    }

    ,
    {"id": 115,
    "block": "Типы данных",
     "topic": "Object.keys, values, entries",
    "level": "medium",
    "question": "Для каких структур поддерживаются методы map.keys(), map.values(), map.entries() и что они возвращают?",
    "answer": "Map, Set, Array. Возвращает перебираемый (итерируемый) объект. Простые объекты также можно перебирать похожими методами, но синтаксис немного отличается."
    } ,
    {"id": 116,
    "block": "Типы данных",
     "topic": "Object.keys, values, entries",
    "level": "medium",
    "question": "Какими способами можно перебрать обычные объекты и что эти методы возвращают?",
    "answer": ["Object.keys(obj) – возвращает массив ключей.", "Object.values(obj) – возвращает массив значений.", "Object.entries(obj) – возвращает массив пар [ключ, значение]."]
    } ,
    {"id": 117,
    "block": "Типы данных",
     "topic": "Object.keys, values, entries",
    "level": "medium",
    "question": "Все ли свойства перебирают методы Object.keys/values/entries?",
    "answer": "Так же, как и цикл for..in, эти методы игнорируют свойства, использующие Symbol(...) в качестве ключей."
    } ,
    {"id": 118,
    "block": "Типы данных",
     "topic": "Object.keys, values, entries",
    "level": "medium",
    "question": "Как трансформировать объект, учитывая, что у него нет методов типа filter, map и т.д.? ",
    "answer": ["Если мы хотели бы их применить, то можно использовать Object.entries с последующим вызовом Object.fromEntries:", "Вызов Object.entries(obj) возвращает массив пар ключ/значение для obj.", "На нём вызываем методы массива, например, map.", "Используем Object.fromEntries(array) на результате, чтобы преобразовать его обратно в объект."]
    }


    ,
    {"id": 119,
    "block": "Типы данных",
     "topic": "Date",
    "level": "low",
    "question": "Что содержит объект Date? Как его можно использовать?",
    "answer": ["Он содержит дату и время, а также предоставляет методы управления ими.", "Например, его можно использовать для хранения времени создания/изменения, для измерения времени или просто для вывода текущей даты."]
    },
    {"id": 120,
    "block": "Типы данных",
     "topic": "Date",
    "level": "low",
    "question": "Какие есть способы создать объект Date?",
    "answer": ["- new Date()", "Без аргументов – создать объект Date с текущими датой и временем", "- new Date(milliseconds)", "Создать объект Date с временем, равным количеству миллисекунд (тысячная доля секунды), прошедших с 1 января 1970 года UTC+0."]
    },
    {"id": 121,
    "block": "Типы данных",
     "topic": "Date",
    "level": "low",
    "question": "Что такое timestamp? Как его применять?",
    "answer": ["Целое число, представляющее собой количество миллисекунд, прошедших с начала 1970 года. ", "Это – легковесное численное представление даты. Из таймстампа всегда можно получить дату с помощью new Date(timestamp) и преобразовать существующий объект Date в таймстамп, используя метод date.getTime() (см. ниже)."]
    },
    {"id": 122,
    "block": "Типы данных",
     "topic": "Date",
    "level": "low",
    "question": "В какой последовательности нужно передавать параметры в объект Date?",
    "answer": "new Date(year, month, date, hours, minutes, seconds, ms)"
    },
    {"id": 123,
    "block": "Типы данных",
     "topic": "Date",
    "level": "low",
    "question": "Как создать объект Date для даты 12 декабря 2013 года? Что будет если не указать день? Можно ли указать только год в объекте Date?",
    "answer": "new Date(2012, 11, 12). Если не указывать день, он будет считаться равным 1. Только год указать нельзя, т.к. первые два параметра обязательны."
    },
    {"id": 124,
    "block": "Типы данных",
     "topic": "Date",
    "level": "low",
    "question": "Необходимо назвать методы для получения года, месяца, дня месяца, часов, минут, секунд и миллисекунд.",
    "answer": "getFullYear(), getMonth(), getDate(), getHours(), getMinutes(), getSeconds(), getMilliseconds()"
    },
    {"id": 125,
    "block": "Типы данных",
     "topic": "Date",
    "level": "low",
    "question": "Как получить день недели? От какого дня идёт отсчёт и какой цифре равен этот день?",
    "answer": "getDay(). Воскресенье. 0."
    },
    {"id": 126,
    "block": "Типы данных",
     "topic": "Date",
    "level": "medium",
    "question": "Как получить разницу в минутах между UTC и местным часовым поясом?",
    "answer": "getTimezoneOffset()"
    },
    {"id": 127,
    "block": "Типы данных",
     "topic": "Date",
    "level": "low",
    "question": "Что такое timestamp? Как получить его для заданной даты?",
    "answer": "getTime()"
    },
    {"id": 128,
    "block": "Типы данных",
     "topic": "Date",
    "level": "low",
    "question": "Какие существуют методы для установки компонентов даты и времени (8 методов)?",
    "answer": ["setFullYear(year, [month], [date])", "setMonth(month, [date])", "setDate(date)", "setHours(hour, [min], [sec], [ms])", "setMinutes(min, [sec], [ms])", "setSeconds(sec, [ms])", "setMilliseconds(ms)", "setTime(milliseconds) (устанавливает дату в виде целого количества миллисекунд, прошедших с 01.01.1970 UTC)"]
    },
    {"id": 129,
    "block": "Типы данных",
     "topic": "Date",
    "level": "low",
    "question": "Как работает автоисправление даты?",
    "answer": ["Можно устанавливать компоненты даты вне обычного диапазона значений, а объект сам себя исправит. Неправильные компоненты даты автоматически распределяются по остальным. ", "Предположим, нам требуется увеличить дату «28 февраля 2016» на два дня. В зависимости от того, високосный это год или нет, результатом будет «2 марта» или «1 марта». Нам об этом думать не нужно. Просто прибавляем два дня. Объект Date позаботится об остальном"]
    },
    {"id": 130,
    "block": "Типы данных",
     "topic": "Date",
    "level": "low",
    "question": "Что будет если объект попытаться преобразовать в число?",
    "answer": ["Если объект Date преобразовать в число, то получим таймстамп по аналогии с date.getTime().", "let date = new Date();", "alert(+date); // количество миллисекунд, то же самое, что date.getTime()"]
    },
    {"id": 131,
    "block": "Типы данных",
     "topic": "Date",
    "level": "low",
    "question": "Можно ли вычитать даты? Что получится, если попытаться это сделать?",
    "answer": ["Важный побочный эффект: даты можно вычитать, в результате получаем разность в миллисекундах.", "Этот приём можно использовать для измерения времени"]
    },
    {"id": 132,
    "block": "Типы данных",
     "topic": "Date",
    "level": "medium",
    "question": "Какая есть аналогия методу new Date().getTime(), для чего это используется и почему лучше использовать другой вариант?",
    "answer": ["Если нужно просто измерить время, объект Date нам не нужен.", "Существует особый метод Date.now(), возвращающий текущую метку времени.", "Семантически он эквивалентен new Date().getTime(), однако метод не создаёт промежуточный объект Date. Так что этот способ работает быстрее и не нагружает сборщик мусора.", "Данный метод используется из соображений удобства или когда важно быстродействие, например, при разработке игр на JavaScript или других специализированных приложений."]
    },
    {"id": 133,
    "block": "Типы данных",
     "topic": "Date",
    "level": "medium",
    "question": "Что такое бенчмаркинг и как им лучше пользоваться?",
    "answer": ["Например, сравним две функции, вычисляющие разницу между двумя датами: какая сработает быстрее?", "Подобные вычисления, замеряющие производительность, также называют «бенчмарками» (benchmark).", "Вот пример записи: ", "alert( 'Время diffSubtract: ' + bench(diffSubtract) + 'мс' );", "alert( 'Время diffGetTime: ' + bench(diffGetTime) + 'мс' );", "Для получения наиболее достоверных результатов тестирования производительности весь набор бенчмарков нужно запускать по нескольку раз."]
    },
    {"id": 134,
    "block": "Типы данных",
     "topic": "Date",
    "level": "low",
    "question": "Как работает метод Date.parse(str)? Какой вид str он принимает?",
    "answer": ["Метод Date.parse(str) считывает дату из строки.", "Формат строки должен быть следующим: YYYY-MM-DDTHH:mm:ss.sssZ, где:", "YYYY-MM-DD – это дата: год-месяц-день.", "Символ 'T' используется в качестве разделителя.", "HH:mm:ss.sss – время: часы, минуты, секунды и миллисекунды.", "Необязательная часть 'Z' обозначает часовой пояс в формате +-hh:mm. Если указать просто букву Z, то получим UTC+0.", "Возможны и более короткие варианты, например, YYYY-MM-DD или YYYY-MM, или даже YYYY.", "Вызов Date.parse(str) обрабатывает строку в заданном формате и возвращает таймстамп (количество миллисекунд с 1 января 1970 года UTC+0). Если формат неправильный, возвращается NaN."]
    }

    ,
    {"id": 135,
    "block": "Типы данных",
     "topic": "Формат JSON, метод toJSON",
    "level": "low",
    "question": "Что такое JSON?",
    "answer": "JSON (JavaScript Object Notation) – это общий формат для представления значений и объектов. Его описание задокументировано в стандарте RFC 4627.  Формат данных, который имеет собственный независимый стандарт и библиотеки для большинства языков программирования."
    },
    {"id": 136,
    "block": "Типы данных",
     "topic": "Формат JSON, метод toJSON",
    "level": "low",
    "question": "Какие есть методы у JSON и что они делают?",
    "answer": ["JSON.stringify для преобразования объектов в JSON.", "JSON.parse для преобразования JSON обратно в объект."]
    },
    {"id": 137,
    "block": "Типы данных",
     "topic": "Формат JSON, метод toJSON",
    "level": "low",
    "question": "Что такое сериализированный объект, как его можно создать и что мы можем с ним делать?",
    "answer": "Метод JSON.stringify(student) берёт объект и преобразует его в строку. Полученная строка json называется JSON-форматированным или сериализованным объектом. Мы можем отправить его по сети или поместить в обычное хранилище данных."
    },
    {"id": 138,
    "block": "Типы данных",
     "topic": "Формат JSON, метод toJSON",
    "level": "low",
    "question": "Можно ли применять JSON.stringify() к примитивам? Какие типы данных он поддерживает?",
    "answer": ["Да.", "Поддерживаемые типы: объекты, массивы, примитивы, строки, числа, логические значения, null."]
    },
    {"id": 139,
    "block": "Типы данных",
     "topic": "Формат JSON, метод toJSON",
    "level": "low",
    "question": "Какие свойства объектов пропускает JSON? И почему?",
    "answer": ["JSON является независимой от языка спецификацией для данных, поэтому JSON.stringify пропускает некоторые специфические свойства объектов JavaScript. А именно:", "Свойства-функции (методы).", "Символьные свойства.", "Свойства, содержащие undefined."]
    },
    {"id": 140,
    "block": "Типы данных",
     "topic": "Формат JSON, метод toJSON",
    "level": "low",
    "question": "Как выглядит полный синтаксис JSON.stringify? Какие параметры за что отвечают?",
    "answer": ["let json = JSON.stringify(value[, replacer, space])", "value - значение для кодирования", "replacer - массив свойств для кодирования или функция соответствия function(key, value).", "space - дополнительное пространство (отступы), используемое для форматирования"]
    },
    {"id": 141,
    "block": "Типы данных",
     "topic": "Формат JSON, метод toJSON",
    "level": "low",
    "question": "Для чего нужен метод JSON.parse()? ",
    "answer": "Чтобы декодировать JSON-строку, нам нужен другой метод с именем JSON.parse."
    },
    {"id": 142,
    "block": "Типы данных",
     "topic": "Формат JSON, метод toJSON",
    "level": "low",
    "question": "Полный синтаксис JSON.parse()? За что отвечает каждый параметр?",
    "answer": ["JSON.parse(str, [reviver]);", "str - JSON для преобразования в объект.", "reviver - необязательная функция, которая будет вызываться для каждой пары (ключ, значение) и может преобразовывать значение."]
    },
    {"id": 143,
    "block": "Типы данных",
     "topic": "Продвинутая работа с функциями",
    "level": "low",
    "question": "Как написать комментарий в JSON?",
    "answer": "JSON не поддерживает комментарии. Добавление комментария в JSON делает его недействительным."
    },
    {"id": 144,
    "block": "Типы данных",
     "topic": "Формат JSON, метод toJSON",
    "level": "low",
    "question": "Что происходит, при вызове JSON.stringify если у объекта есть встроенный метод toJSON()? Что изменится, если создать кастомный метод toJSON в объекте?",
    "answer": "Если объект имеет метод встроенный toJSON, то он вызывается через JSON.stringify. То же самое происходит, если создать свой toJSON в объекте."
    }

    ,
    {"id": 145,
    "block": "Продвинутая работа с функциями",
     "topic": "Рекурсия и стек",
    "level": "medium",
    "question": "Что такое рекурсия?",
    "answer": ["Рекурсия – это приём программирования, полезный в ситуациях, когда задача может быть естественно разделена на несколько аналогичных, но более простых задач. Или когда задача может быть упрощена до несложных действий плюс простой вариант той же задачи. Или, как мы скоро увидим, для работы с определёнными структурами данных.", "В процессе выполнения задачи в теле функции могут быть вызваны другие функции для выполнения подзадач. Частный случай подвызова – когда функция вызывает сама себя. Это как раз и называется рекурсией.", "То есть, рекурсия - это термин в программировании, означающий вызов функцией самой себя. Рекурсивные функции могут быть использованы для элегантного решения определённых задач."]
    },
    {"id": 146,
    "block": "Продвинутая работа с функциями",
     "topic": "Рекурсия и стек",
    "level": "medium",
    "question": "Что такое шаг и база рекурсии?",
    "answer": "Когда функция вызывает саму себя, это называется шагом рекурсии. База рекурсии – это такие аргументы функции, которые делают задачу настолько простой, что решение не требует дальнейших вложенных вызовов."
    },
    {"id": 147,
    "block": "Продвинутая работа с функциями",
     "topic": "Рекурсия и стек",
    "level": "medium",
    "question": "Напиши функцию, которая возводит x в степень n с применением рекурсии",
    "answer": "function pow(x, n) { return (n == 1) ? x : (x * pow(x, n - 1)); }"
    },
    {"id": 148,
    "block": "Продвинутая работа с функциями",
     "topic": "Рекурсия и стек",
    "level": "medium",
    "question": "Что такое глубина рекурсии?",
    "answer": "Общее количество вложенных вызовов (включая первый)."
    },
    {"id": 149,
    "block": "Продвинутая работа с функциями",
     "topic": "Рекурсия и стек",
    "level": "medium",
    "question": "Где хранится информация о процессе выполнения запущенной функции?",
    "answer": "В её контексте выполнения (execution context)."
    },
    {"id": 150,
    "block": "Продвинутая работа с функциями",
     "topic": "Рекурсия и стек",
    "level": "medium",
    "question": "Что такое контекст выполнения? Что он в себя включает?",
    "answer": "Это специальная внутренняя структура данных, которая содержит информацию о вызове функции. Она включает в себя конкретное место в коде, на котором находится интерпретатор, локальные переменные функции, значение this (мы не используем его в данном примере) и прочую служебную информацию."
    },
    {"id": 151,
    "block": "Продвинутая работа с функциями",
     "topic": "Рекурсия и стек",
    "level": "medium",
    "question": "Что происходит когда функция производит вложенный вызов?",
    "answer": ["Выполнение текущей функции приостанавливается.", "Контекст выполнения, связанный с ней, запоминается в специальной структуре данных – стеке контекстов выполнения.", "Выполняются вложенные вызовы, для каждого из которых создаётся свой контекст выполнения.", "После их завершения старый контекст достаётся из стека, и выполнение внешней функции возобновляется с того места, где она была остановлена."]
    },
    {"id": 152,
    "block": "Продвинутая работа с функциями",
     "topic": "Рекурсия и стек",
    "level": "medium",
    "question": "Что такое связанный список?",
    "answer": ["Структура данных поддерживающая быстрые вставка/удаление. Элемент связанного списка определяется рекурсивно как объект с:", "value", "next - свойство, ссылающееся на следующий элемент связанного списка или null, если это последний элемент."]
    }

    ,
    {"id": 153,
    "block": "Продвинутая работа с функциями",
     "topic": "Остаточные параметры и оператор расширения",
    "level": "medium",
    "question": "Как обозначаются остаточные параметры? И Где они должны быть расположены?",
    "answer": ["Остаточные параметры могут быть обозначены через три точки ... Располагаются в конце передачи параметров при объявлении функции", "Остаточные параметры используются, чтобы создавать новые функции с неопределённым числом аргументов."]
    },
    {"id": 154,
    "block": "Продвинутая работа с функциями",
     "topic": "Остаточные параметры и оператор расширения",
    "level": "medium",
    "question": "Что такое arguments? Что он в себе содержит? Какие методы массивов поддерживает? ",
    "answer": "Это псевдомассив. Содержит все аргументы функции. Его можно перебрать, но, так как, это не массив, то и методы его он не поддерживает"
    },
    {"id": 155,
    "block": "Продвинутая работа с функциями",
     "topic": "Остаточные параметры и оператор расширения",
    "level": "medium",
    "question": "Что будет если в стрелочной функции мы попытаемся обратиться к arguments? Почему?",
    "answer": "Если мы обратимся к arguments из стрелочной функции, то получим аргументы внешней «нормальной» функции, т.к. стрелочные функции не имеют arguments"
    },
    {"id": 156,
    "block": "Продвинутая работа с функциями",
     "topic": "Остаточные параметры и оператор расширения",
    "level": "medium",
    "question": "Что такое оператор расширения? Как им пользоваться? Где его можно ставить?",
    "answer": ["Используется при вызове функции. Расширяет перебираемый объект в список аргументов. Можно передать и несколько итерирумеых объектов. Располагаться может в вызове функции на любой позиции или в любом другом месте кода (кроме объявления функции, где оператор rest находящийся только в коцне параметров)", "С помощью оператора расширения можно вставить массив в функцию, которая по умолчанию работает с обычным списком аргументов.", "let arr1 = [1, -2, 3, 4];", "let arr2 = [8, 3, -8, 1];", "alert( Math.max(1, ...arr1, 2, ...arr2, 25) ); // 25"]
    },
    {"id": 157,
    "block": "Продвинутая работа с функциями",
     "topic": "Остаточные параметры и оператор расширения",
    "level": "medium",
    "question": "Какие есть способы превратить строку в массив символов (3 способа)?",
    "answer": ["let str = 'Привет';", "alert( [...str] ); // П,р,и,в,е,т", "С помощью Array.from(str)", "С помощью split"]
    }

    ,
    {"id": 158,
    "block": "Продвинутая работа с функциями",
     "topic": "Замыкание",
    "level": "medium",
    "question": "Что такое лексическое окружение LexicalEnvironment? Из чего он состоит?",
    "answer": ["В JavaScript у каждой выполняемой функции, блока кода и скрипта есть связанный с ними внутренний (скрытый) объект, называемый лексическим окружением LexicalEnvironment.", "«Лексическое окружение» – это специальный внутренний объект. Мы не можем получить его в нашем коде и изменять напрямую. Сам движок JavaScript может оптимизировать его, уничтожать неиспользуемые переменные для освобождения памяти и выполнять другие внутренние уловки, но видимое поведение объекта должно оставаться таким, как было описано.", "Объект лексического окружения состоит из двух частей:", "1. Environment Record – объект, в котором как свойства хранятся все локальные переменные (а также некоторая другая информация, такая как значение this).", "2. Ссылка на внешнее лексическое окружение – то есть то, которое соответствует коду снаружи (снаружи от текущих фигурных скобок).Эта ссылка устанавливается в значение [[Environment]]"]
    },
    {"id": 159,
    "block": "Продвинутая работа с функциями",
     "topic": "Замыкание",
    "level": "medium",
    "question": "Что такое переменная в рамках лексического окружения?",
    "answer": ["Переменная – это свойство специального внутреннего объекта, связанного с текущим выполняющимся блоком/функцией/скриптом.", "Работа с переменными – это на самом деле работа со свойствами этого объекта."]
    },
    {"id": 160,
    "block": "Продвинутая работа с функциями",
     "topic": "Замыкание",
    "level": "medium",
    "question": "Каким образом осуществляется доступ к переменной в лексическом окружении?",
    "answer": "Когда код хочет получить доступ к переменной – сначала происходит поиск во внутреннем лексическом окружении, затем во внешнем, затем в следующем и так далее, до глобального."
    },
    {"id": 161,
    "block": "Продвинутая работа с функциями",
     "topic": "Замыкание",
    "level": "medium",
    "question": "Какая функция называется вложенной?",
    "answer": "Функция называется «вложенной», когда она создаётся внутри другой функции."
    },
    {"id": 162,
    "block": "Продвинутая работа с функциями",
     "topic": "Замыкание",
    "level": "medium",
    "question": "Что такое [[Environment]] ?",
    "answer": "Все функции «при рождении» получают скрытое свойство [[Environment]], которое ссылается на лексическое окружение места, где они были созданы. Это то, каким образом функции знают, где они были созданы."
    },
    {"id": 163,
    "block": "Продвинутая работа с функциями",
     "topic": "Замыкание",
    "level": "medium",
    "question": "Что такое замыкание?",
    "answer": ["Замыкание – li. В некоторых языках это невозможно, или функция должна быть написана специальным образом, чтобы получилось замыкание. Но, как было описано выше, в JavaScript, все функции изначально являются замыканиями (есть только одно исключение, про которое будет рассказано в Синтаксис 'new Function').", "То есть, они автоматически запоминают, где были созданы, с помощью скрытого свойства [[Environment]] и все они могут получить доступ к внешним переменным.", "Когда на собеседовании фронтенд-разработчик получает вопрос: «что такое замыкание?», – правильным ответом будет определение замыкания и объяснения того факта, что все функции в JavaScript являются замыканиями, и, может быть, несколько слов о технических деталях: свойстве [[Environment]] и о том, как работает лексическое окружение."]
    },
    {"id": 164,
    "block": "Продвинутая работа с функциями",
     "topic": "Замыкание",
    "level": "medium",
    "question": "Сколько лексических окружений в цикле for (let i = 0; i < 10; i++) {…}? Почему?",
    "answer": "10. При каждой итерации создаётся новое своё собственное лексическое окружение."
    }
]}