{"data": [
    {
    "id": 1,
    "block": "Interview",
    "topic": "-",
    "question": "В чем разница между null и undefined? Что у них общего?",
    "answer": "null - отсутствующее значение, undefined - значение не было присвоено. Общее: при приведение к логическим значениям, они оба - false, являются примитивными значениями"
    },
    {
    "id": 2,
    "block": "Interview",
    "topic": "-",
    "question": "Для чего используется оператор '&&'? Как он работает?",
    "answer": "Для логического сравнения. Возвращает лиюо первое ложное значение, либо последнее true"
    },
    {
    "id": 3,
    "block": "Interview",
    "topic": "-",
    "question": "Для чего используется оператор '||'? Как он работает?",
    "answer": "Для логического сравнения. Возвращает либо первое true, либо последнее false"
    },
    {
    "id": 4,
    "block": "Interview",
    "topic": "-",
    "question": "Является ли использование унарного плюса (оператор '+') самым быстрым способом преобразования строки в число? Почему?",
    "answer": "Согласно MDN оператор '+' действительно является самым быстрым способом преобразования строки в число, поскольку он не выполняет никаких операций со значением, которое является числом."
    },
    {
    "id": 5,
    "block": "Interview",
    "topic": "-",
    "question": "Что такое DOM? Как он появляется? Что из себя представляет? Для чего используется?",
    "answer": "DOM или Document Object Model (объектная модель документа) — это прикладной программный интерфейс (API) для работы с HTML и XML документами. Когда браузер первый раз читает («парсит») HTML документ, он формирует большой объект, действительно большой объект, основанный на документе — DOM. DOM представляет собой древовидную структуру (дерево документа). DOM используется для взаимодействия и изменения самой структуры DOM или его отдельных элементов и узлов."
    },
    {
    "id": 6,
    "block": "Interview",
    "topic": "-",
    "question": "Что такое распространение события (Event Propogation)?",
    "answer": ["Когда какое-либо событие происходит в элементе DOM, оно на самом деле происходит не только в нем. Событие «распространяется» от объекта Window до вызвавшего его элемента (event.target). При этом событие последовательно пронизывает (затрагивает) всех предков целевого элемента. Распространение события имеет три стадии или фазы:", "Фаза погружения (захвата, перехвата) — событие возникает в объекте Window и опускается до цели события через всех ее предков.", "Целевая фаза — это когда событие достигает целевого элемента.", "Фаза всплытия — событие поднимается от event.target, последовательно проходит через всех его предков и достигает объекта Window."]
    },
    {
    "id": 7,
    "block": "Interview",
    "topic": "-",
    "question": "Что такое всплытие события?",
    "answer": "Когда событие происходит в элементе DOM, оно затрагивает не только этот элемент. Событие «всплывает» (подобно пузырьку воздуха в воде), переходит от элемента, вызвавшего событие (event.target), к его родителю, затем поднимается еще выше, к родителю родителя элемента, пока не достигает объекта Window."
    },
    {
    "id": 8,
    "block": "Interview",
    "topic": "-",
    "question": "Что такое погружение события?",
    "answer": "Когда событие происходит в элементе DOM, оно происходит не только в нем. В фазе погружения событие опускается от объекта Window до цели события через всех его предков."
    },
    {
    "id": 9,
    "block": "Interview",
    "topic": "-",
    "question": "В чем разница между методами event.preventDefault() и event.stopPropagation()?",
    "answer": "Метод event.preventDefault() отключает поведение элемента по умолчанию. Если использовать этот метод в элементе form, то он предотвратит отправку формы (submit). Если использовать его в contextmenu, то контекстное меню будет отключено (данный метод часто используется в keydown для переопределения клавиатуры, например, при создании музыкального/видео плеера или текстового редактора — прим. пер.). Метод event.stopPropagation() отключает распространение события (его всплытие или погружение)."
    },
    {
    "id": 10,
    "block": "Interview",
    "topic": "-",
    "question": "Как узнать об использовании метода event.preventDefault()?",
    "answer": "Для этого мы можем использовать свойство event.defaulPrevented, возвращающее логическое значение, служащее индикатором применения к элементу метода event.preventDefault."
    },
    {
    "id": 11,
    "block": "Interview",
    "topic": "-",
    "question": "Почему obj.someprop.x приводит к ошибке? const obj = {}; console.log(obj.someprop.x);",
    "answer": "Мы пытается получить доступ к свойству x свойства someprop, которое имеет значение undefined. obj.__proto__.__proto = null, поэтому возвращается undefined, а у undefined нет свойства x."
    },
    {
    "id": 12,
    "block": "Interview",
    "topic": "-",
    "question": "Что такое цель события или целевой элемент (event.target)?",
    "answer": "Простыми словами, event.target — это элемент, в котором происходит событие, или элемент, вызвавший событие."
    },
    {
    "id": 13,
    "block": "Interview",
    "topic": "-",
    "question": "Что такое текущая цель события (event.currentTarget)?",
    "answer": "Event.currentTarget — это элемент, к которому прикреплен прослушиватель событий."
    },
    {
    "id": 14,
    "block": "Interview",
    "topic": "-",
    "question": "В чем разница между операторами '=='' и '==='?",
    "answer": "== абстрактное или нестрогое равенство, === строгое равенство. Первый сравнивает с приведением типов, второй - без."
    },
    {
    "id": 15,
    "block": "Interview",
    "topic": "-",
    "question": "Для чего используется оператор '!!'?",
    "answer": "Приведение к логическому типу"
    },
    {
    "id": 16,
    "block": "Interview",
    "topic": "-",
    "question": "Как записать несколько выражений в одну строку?",
    "answer": "Для этого мы можем использовать оператор ',' (запятая). Этот оператор «двигается» слева направо и возвращает значение последнего выражения или операнда."
    },
    {
    "id": 17,
    "block": "Interview",
    "topic": "-",
    "question": "Что такое поднятие (Hoisting)?",
    "answer": ["Поднятие — это термин, описывающий подъем переменной или функции в глобальную или функциональную области видимости.", "Для того, чтобы понять, что такое Hoisting, необходимо разобраться с тем, что представляет собой контекст выполнения.", "Контекст выполнения — это среда, в которой выполняется код. Контекст выполнения имеет две фазы — компиляция и собственно выполнение.", "Компиляция. В этой фазе функциональные выражения и переменные, объявленные с помощью ключевого слова «var», со значением undefined поднимаются в самый верх глобальной (или функциональной) области видимости (как бы перемещаются в начало нашего кода. Это объясняет, почему мы можем вызывать функции до их объявления — прим. пер.).", "Выполнение. В этой фазе переменным присваиваются значения, а функции (или методы объектов) вызываются или выполняются.", "Запомните: поднимаются только функциональные выражения и переменные, объявленные с помощью ключевого слова «var». Обычные функции и стрелочные функции, а также переменные, объявленные с помощью ключевых слов «let» и «const» не поднимаются."]
    },
    {
    "id": 18,
    "block": "Interview",
    "topic": "-",
    "question": "Что такое область видимости (Scope)?",
    "answer": ["Область видимости — это место, где (или откуда) мы имеем доступ к переменным или функциям. JS имеем три типа областей видимости: глобальная, функциональная и блочная (ES6).", "Глобальная область видимости — переменные и функции, объявленные в глобальном пространстве имен, имеют глобальную область видимости и доступны из любого места в коде.", "Функциональная область видимости (область видимости функции) — переменные, функции и параметры, объявленные внутри функции, доступны только внутри этой функции.", "Блочная область видимости — переменные (объявленные с помощью ключевых слов «let» и «const») внутри блока ({ }), доступны только внутри него.", "Область видимости — это также набор правил, по которым осуществляется поиск переменной. Если переменной не существует в текущей области видимости, ее поиск производится выше, во внешней по отношению к текущей области видимости. Если и во внешней области видимости переменная отсутствует, ее поиск продолжается вплоть до глобальной области видимости. Если в глобальной области видимости переменная обнаружена, поиск прекращается, если нет — выбрасывается исключение. Поиск осуществляется по ближайшим к текущей областям видимости и останавливается с нахождением переменной. Это называется цепочкой областей видимости (Scope Chain)."]
    },
    {
    "id": 19,
    "block": "Interview",
    "topic": "-",
    "question": "Что такое замыкание (Closures)?",
    "answer": ["Наверное, это самый сложный вопрос из списка. Я постараюсь объяснить, как я понимаю замыкание.", "По сути, замыкание — это способность функции во время создания запоминать ссылки на переменные и параметры, находящиеся в текущей области видимости, в области видимости родительской функции, в области видимости родителя родительской функции и так до глобальной области видимости с помощью цепочки областей видимости. Обычно область видимости определяется при создании функции."]
    },
    {
    "id": 20,
    "block": "Interview",
    "topic": "-",
    "question": "Какие значения в JS являются ложными?",
    "answer": "Ложными являются значения, результатом преобразования которых в логическое значение является false: ['', 0, null, undefined, NaN, false]"
    },
    {
    "id": 21,
    "block": "Interview",
    "topic": "-",
    "question": "Как проверить, является ли значение ложным?",
    "answer": "Следует использовать функцию Boolean или оператор '!!' (двойное отрицание)."
    },
    {
    "id": 22,
    "block": "Interview",
    "topic": "-",
    "question": "Для чего используется директива «use strict»?",
    "answer": ["«use strict» — это директива ES5, которая заставляет весь наш код или код отдельной функции выполняться в строгом режиме. Строгий режим вводит некоторые ограничения по написанию кода, тем самым позволяя избегать ошибок на ранних этапах.", "Нельзя присваивать значения или обращаться к необъявленным переменным", "Запрещено присваивать значения глобальный переменным, доступным только для чтения или записи", "Нельзя удалить «неудаляемое» свойство объекта", "Запрещено дублирование параметров", "Нельзя создавать функции с помощью функции eval", "Значением «this» по умолчанию является undefined"]
    },
    {
    "id": 23,
    "block": "Interview",
    "topic": "-",
    "question": "Какое значение имеет this?",
    "answer": "Обычно this ссылается на значение объекта, который в данный момент выполняет или вызывает функцию. «В данный момент» означает, что значение this меняется в зависимости от контекста выполнения, от того места, где мы используем this."
    },
    {
    "id": 24,
    "block": "Interview",
    "topic": "-",
    "question": "Что такое прототип объекта?",
    "answer": "В двух словах, прототип — это план (схема или проект) объекта. Он используется как запасной вариант для свойств и методов, существующих в данном объекте. Это также один из способов обмена свойствами и функциональностью между объектами. Это основная концепция прототипного наследования в JS."
    },
    {
    "id": 25,
    "block": "Interview",
    "topic": "-",
    "question": "Что такое IIFE? Как её создать?",
    "answer": "IIFE или Immediately Invoked Function Expression — это функция, которая вызывается или выполняется сразу же после создания или объявления. Для создания IIFE необходимо обернуть функцию в круглые скобки (оператор группировки), превратив ее в выражение, и затем вызвать ее с помощью еще одних круглых скобок. Это выглядит так: (function(){})()."
    },
    {
    "id": 26,
    "block": "Interview",
    "topic": "-",
    "question": "Почему результатом сравнения двух похожих объектов является false?",
    "answer": "В JS объекты и примитивы сравниваются по-разному. Примитивы сравниваются по значению. Объекты — по ссылке или адресу в памяти, где хранится переменная. Вот почему первый console.log возвращает false, а второй — true. Переменные «a» и «c» ссылаются на один объект, а переменные «a» и «b» — на разные объекты с одинаковыми свойствами и значениями."
    },
    {
    "id": 27,
    "block": "Interview",
    "topic": "-",
    "question": "Для чего используется метод Function.prototype.apply?",
    "answer": "Apply используется для привязки определенного объекта к значению this вызываемой функции."
    },
    {
    "id": 28,
    "block": "Interview",
    "topic": "-",
    "question": "Для чего используется метод Function.prototype.call?",
    "answer": "Call используется для привязки определенного объекта к значению this вызываемой функции."
    },
    {
    "id": 29,
    "block": "Interview",
    "topic": "-",
    "question": "В чем разница между методами call и apply?",
    "answer": "Отличие между call и apply состоит в том, как мы передаем аргументы в вызываемой функции. В apply аргументы передаются в виде массива, в call — через запятую."
    },
    {
    "id": 30,
    "block": "Interview",
    "topic": "-",
    "question": "Для чего используется метод Function.prototype.bind?",
    "answer": "Bind возвращает новую функцию, значением this которой является объект, указанный в качестве первого параметра. В отличие от bind, call и apply сразу же вызывают функцию."
    },
    {
    "id": 31,
    "block": "Interview",
    "topic": "-",
    "question": "Что такое функциональное программирование и какие особенности JS позволяют говорить о нем как о функциональном языке программирования?",
    "answer": ["Функциональное программирование — это декларативная концепция программирования или образец (паттерн) того, как строятся приложения, как используются функции, содержащие выражения, которые вычисляют значения без изменения аргументов, которые им передаются.", "Объект Array содержит методы map, filter и reduce, которые являются самыми известными функциями в мире функционального программирования из-за их полезности, а также потому, что они не изменяют массив, что делает эти функции «чистыми». Также в JS имеются замыкание и функции высшего порядка, которые являются характеристиками функционального языка программирования."]
    },
    {
    "id": 32,
    "block": "Interview",
    "topic": "-",
    "question": "Что такое функции высшего порядка (Higher Order Functions)?",
    "answer": "Функция высшего порядка — это функция, возвращающая другую функцию или принимающая другую функцию в качестве аргумента."
    },
    {
    "id": 33,
    "block": "Interview",
    "topic": "-",
    "question": "Почему функции в JS называют объектами первого класса (First-class Objects)?",
    "answer": "Функции называют объектами первого класса, потому что они обрабатываются также, как и любое другое значение в JS. Они могут присваиваться переменным, быть свойством объекта (методом), элементом массива, аргументом другой функции, значением, возвращаемым функцией. Единственным отличием функции от любого другого значения в JS является то, что функция может быть выполнена или вызвана."
    },
    {
    "id": 34,
    "block": "Interview",
    "topic": "-",
    "question": "Как бы Вы реализовали метод Array.prototype.map?",
    "answer": "https://habr.com/ru/post/486820/"
    },
    {
    "id": 35,
    "block": "Interview",
    "topic": "-",
    "question": "Как бы Вы реализовали метод Array.prototype.filter?",
    "answer": "https://habr.com/ru/post/486820/"
    },
    {
    "id": 36,
    "block": "Interview",
    "topic": "-",
    "question": "Как бы Вы реализовали метод Array.prototype.reduce?",
    "answer": "https://habr.com/ru/post/486820/"
    },
    {
    "id": 37,
    "block": "Interview",
    "topic": "-",
    "question": "Что такое объект arguments?",
    "answer": "Arguments — это коллекция аргументов, передаваемых функции. Это объект, подобный массиву, у него есть свойство length, мы можем получить доступ к определенному значению с помощью arguments[i], но у него отсутствуют методы forEach, reduce, filter и map. Он позволяет узнать количество параметров функции."
    },
    {
    "id": 38,
    "block": "Interview",
    "topic": "-",
    "question": "Как создать объект, не имеющий прототипа?",
    "answer": "С помощью Object.create: Object.create(null)"
    },
    {
    "id": 39,
    "block": "Interview",
    "topic": "-",
    "question": "Почему в коде 'function myFunc(){let a = b = 0}; myFunc();' переменная b становится глобальной при вызове функции?",
    "answer": "Так происходит, потому что оператор присваивания ('=') имеет правостороннюю ассоциативность, т.е. присваивает значения справа налево. Сначала значение 0 присваивается переменной «b», которая не объявлена. Движок JS делает ее глобальной. Возвращаемое выражением b = 0 значение (0) затем присваивается локальной переменной «a»."
    },
    {
    "id": 40,
    "block": "Interview",
    "topic": "-",
    "question": "Что такое ECMAScript?",
    "answer": "ECMAScript — это спецификация, стандарт скриптовых языков программирования, он является основой JS, поэтому любые изменения ECMAScript отражаются на JS."
    },
    {
    "id": 41,
    "block": "Interview",
    "topic": "-",
    "question": "Что нового привнес в JS стандарт ES6 или ECMAScript2015?",
    "answer": ["Стрелочные функции (Arrow Functions).", "Классы (Classes).", "Шаблонные строки (Template Strings).", "Расширенные объектные литералы (Enhanced Object literals).", "Деструктуризация (Object Destructuring).", "Промисы (Promises).", "Генераторы (Generators).", "Модули (Modules).", "Symbol.", "Прокси (Proxies).", "Множества (Sets).", "Параметры по умолчанию.", "Операторы rest и spread.", "Блочная область видимости (ключевые слова «let» и «const»)."]
    },
    {
    "id": 42,
    "block": "Interview",
    "topic": "-",
    "question": "В чем разница между ключевыми словами «var», «let» и «const»?",
    "answer": "Переменные, объявленные с помощью ключевого слова «var», являются глобальными. Переменные, объявленные с помощью ключевых слов «let» и «const» имеют блочную область видимости. Разница между «let» и «const» состоит в том, что в первом случае мы может менять значение переменной, а во втором — нет (константа)."
    },
    {
    "id": 43,
    "block": "Interview",
    "topic": "-",
    "question": "Что такое стрелочные функции (Arrow Functions)?",
    "answer": "Стрелочные функции создаются быстрее и имеют более читаемый синтаксис, чем функциональные выражения. У стрелочных функций нет доступа к объекту arguments. Для получения параметров, переданных функции, мы можем использовать оператор rest."
    },
    {
    "id": 44,
    "block": "Interview",
    "topic": "-",
    "question": "Что такое классы (Classes)?",
    "answer": "Классы — это относительно новый способ написания функций-конструкторов в JS. Это синтаксический сахар для функций-конструкторов. В основе классов лежат те же прототипы и прототипное наследование."
    },
    {
    "id": 45,
    "block": "Interview",
    "topic": "-",
    "question": "Что такое шаблонные литералы (Template Literals)?",
    "answer": "Шаблонные литералы — относительно новый способ создания строк в JS. Шаблонные литералы создаются с помощью двойных обратных кавычек (``):"
    },
    {
    "id": 46,
    "block": "Interview",
    "topic": "-",
    "question": "Что такое деструктуризация объекта (Object Destructuring)?",
    "answer": "Деструктуризация — относительно новый способ получения (извлечения) значений объекта или массива."
    },
    {
    "id": 47,
    "block": "Interview",
    "topic": "-",
    "question": "Что такое модули (Modules)?",
    "answer": "Модули позволяют объединять (использовать) код из разных файлов и избавляют нас от необходимости держать весь код в одном большом файле. "
    },
    {
    "id": 48,
    "block": "Interview",
    "topic": "-",
    "question": "Что такое объект Set?",
    "answer": "Объект Set позволяет хранить уникальные значения, примитивы и ссылки на объекты. Еще раз: в Set можно добавлять только уникальные значения. Он проверяет хранящиеся в нем значения с помощью алгоритма SameZeroValue."
    },
    {
    "id": 49,
    "block": "Interview",
    "topic": "-",
    "question": "Что такое функция обратного вызова (Callback Function)?",
    "answer": "Функция обратного вызова — это функция, вызов которой отложен на будущее (происходит при некоторых условиях, например, при наступлении события)."
    },
    {
    "id": 50,
    "block": "Interview",
    "topic": "-",
    "question": "Что такое промисы (Promises)? Что возвращает? Для чего были придуманы? Какие 4 состояние есть?",
    "answer": ["Промисы — это один из приемов работы с асинхронным кодом в JS. Они возвращают результат асинхронной операции. Промисы были придуманы для решения проблемы так называемого «ада функций обратного вызова»", "Есть 4 состояния:", "Ожидание — начальное состояние промиса. Результата промиса неизвестен, поскольку операция не завершена.", "Выполнено — асинхронная операция выполнена, имеется результат.", "Отклонено — асинхронная операция не выполнена, имеется причина.", "Завершено — выполнено или отклонено."]
    },
    {
    "id": 51,
    "block": "Interview",
    "topic": "-",
    "question": " Что такое async/await? Что делает?",
    "answer": "Async/await — относительно новый способ написания асинхронного (неблокирующего) кода в JS. Им оборачивают промис. Он делает код более читаемым и чистым, чем промисы и функции обратного вызова."
    },
    {
    "id": 52,
    "block": "Interview",
    "topic": "-",
    "question": "В чем разница между spread-оператором и rest-оператором?",
    "answer": "Операторы spread и rest имеют одинаковый синтаксис ('...'). Разница состоит в том, что с помощью spread мы передаем или распространяем данные массива на другие данные, а с помощью rest — получаем все параметры функции и помещаем их в массив (или извлекаем часть параметров)."
    },
    {
    "id": 53,
    "block": "Interview",
    "topic": "-",
    "question": "Что такое параметры по умолчанию (Default Parameters)?",
    "answer": "Это относительно новый способ определения значений переменных по умолчанию."
    },
    {
    "id": 54,
    "block": "Interview",
    "topic": "-",
    "question": "Что такое объектная обертка (Wrapper Objects)?",
    "answer": "Примитивы строка, число и boolean имеют свойства и методы, несмотря на то, что они не являются объектами. У каждого примитива, кроме null и undefined, есть объект-обертка. Такими объектами являются String, Number, Boolean, Symbol и BigInt. Временный объект отбрасывается по завершении работы со свойством или методом."
    },
    {
    "id": 55,
    "block": "Interview",
    "topic": "-",
    "question": "В чем разница между явным и неявным преобразованием или приведением к типу (Implicit and Explicit Coercion)?",
    "answer": "Неявное преобразование — это способ приведения значения к другому типу без нашего ведома (участия). Явное преобразование предполагает наше участие в приведении значения к другому типу."
    },
    {
    "id": 56,
    "block": "Interview",
    "topic": "-",
    "question": "Что такое NaN? Как проверить, является ли значение NaN?",
    "answer": "NaN или Not A Number (не число) — это значение, получаемое в результате выполнения числовой операции над нечисловым значением."
    },
    {
    "id": 57,
    "block": "Interview",
    "topic": "-",
    "question": "Как проверить, является ли значение массивом?",
    "answer": "Для этого следует использовать метод Array.isArray()"
    },
    {
    "id": 58,
    "block": "Interview",
    "topic": "-",
    "question": "Как проверить, что число является четным, без использования деления по модулю или деления с остатком (оператора '%')?",
    "answer": "Для решения данной задачи можно использовать оператор '&' (бинарное и). Оператор '&' сравнивает операнды как бинарные значения"
    },
    {
    "id": 59,
    "block": "Interview",
    "topic": "-",
    "question": "Как определить наличие свойства в объекте?",
    "answer": ["Есть 3 способа:", "Оператор in", "метод hasOwnProperty", "индексная нотация массива (object['prop'])"]
    },
    {
    "id": 60,
    "block": "Interview",
    "topic": "-",
    "question": "Что такое AJAX?",
    "answer": "AJAX или Asyncronous JavaScript and XML — это набор взаимосвязанных технологий, которые позволяют работать с данными в асинхронном режиме. Это означает, что мы можем отправлять данные на сервер и получать данные с него без перезагрузки веб-страницы."
    },
    {
    "id": 61,
    "block": "Interview",
    "topic": "-",
    "question": "Как в JS создать объект?",
    "answer": "Объектный литерал, Функция-конструктор или Метод Object.create"
    },
    {
    "id": 62,
    "block": "Interview",
    "topic": "-",
    "question": "В чем разница между методами Object.freeze и Object.seal?",
    "answer": "Разница заключается в том, что при использовании метода Object.freeze мы не можем менять или редактировать свойства объекта, а при использовании Object.seal у нас такая возможность имеется."
    },
    {
    "id": 63,
    "block": "Interview",
    "topic": "-",
    "question": "В чем разница между оператором «in» и методом hasOwnProperty?",
    "answer": "Отличие состоит в том, что оператор «in» проверяет наличие свойства не только в самом объекте, но и в его прототипах, а метод hasOwnProperty — только в объекте."
    },
    {
    "id": 64,
    "block": "Interview",
    "topic": "-",
    "question": "Какие приемы работы с асинхронным кодом в JS Вы знаете?",
    "answer": ["Функции обратного вызова (Callbacks).", "Промисы (Promises).", "Async/await.", "Библиотеки вроде async.js, blueprint, q, co."]
    },
    {
    "id": 65,
    "block": "Interview",
    "topic": "-",
    "question": "В чем разница между обычной функцией и функциональным выражением?",
    "answer": "Функцию, созданную через функциональное выражение можно использовать в любом месте кода, а через Function Declaration - нет."
    },
    {
    "id": 66,
    "block": "Interview",
    "topic": "-",
    "question": "Как в JS вызвать функцию?",
    "answer": ["В JS существует 4 способа вызвать функцию. Вызов определяет значение this или «владельца» функции.", "Вызов в качестве функции. Если функция вызывается как метод, конструктор или с помощью методов apply или call, значит она вызывается как функция. Владельцем такой функции является объект window.", "Вызов в качестве метода. Когда функция является свойством объекта, мы называем ее методом. Когда вызывается метод, значением this становится объект этого метода.", "Вызов в качестве конструктора. Когда функция вызывается с использованием ключевого слова «new», мы называем такую функцию конструктором. При этом создается пустой объект, являющийся значением this.", "Вызов с помощью методов apply или call. Мы используем эти методы, когда хотим явно определить значение this или владельца функции."]
    },
    {
    "id": 67,
    "block": "Interview",
    "topic": "-",
    "question": "Что такое запоминание или мемоизация (Memoization)? Какой есть недостаток?",
    "answer": "Мемоизация — это прием создания функции, способной запоминать ранее вычисленные результаты или значения. Преимущество мемоизации заключается в том, что мы избегаем повторного выполнения функции с одинаковыми аргументами. Недостатком является то, что мы вынуждены выделять дополнительную память для сохранения результатов."
    },
    {
    "id": 68,
    "block": "Interview",
    "topic": "-",
    "question": "Почему typeof null возвращает object? Как проверить, является ли значение null?",
    "answer": "typeof null == 'object' всегда будет возвращать true по историческим причинам. Поступало предложение исправить эту ошибку, изменив typeof null = 'object' на typeof null = 'null', но оно было отклонено в интересах сохранения обратной совместимости (такое изменение повлекло бы за собой большое количество ошибок). Для проверки, является ли значение null можно использовать оператор строгого равенства (===)."
    },
    {
    "id": 69,
    "block": "Interview",
    "topic": "-",
    "question": "Для чего используется ключевое слово «new»? Что оно делает?",
    "answer": ["Ключевое слово «new» используется в функциях-конструкторах для создания нового объекта (нового экземпляра класса).", "Ключевое слово «new» делает 4 вещи:", "Создает пустой объект.", "Привязывает к нему значение this.", "Функция наследует от functionName.prototype.", "Возвращает значение this, если не указано иное."]
    }
]}